# AOC - Advent of code solutions

Advent of code 2022 solutions in a different language everyday

## Running

A RUN.md file exists for evey solution explaining how to run it.

> **Warning** 
> Make sure to put your session token (with a newline at the end) in a file called session here.

## Languages

- **1**. **bash** + **C** Didn't exactly plan to do a language a day yet, so I did one per challenge, pretty straight forward, using libcurl to get the input in the c solution was probably harder than part 2 itself.
- **2**. **rust** Probably shouldn't have used one of the language I'm the most familiar with first. Again pretty easy.
- **3**. (x86) **asm** Surpisingly not my longest solution.
- **4**. **haskell** Probably one of my favourite functional language in retrospect, although it could also be that harder challenges don't really provide the best first experience with a language.
- **5**. **lua** Pretty good language, interesting approach (no vector, only hashtable), I couldn't really figure out the build system/package manager though (luarocks).
- **6**. **nim** I didn't expect the standard library to be that complete (http(s) support, sets, ...). Felt like a faster python.
- **7**. **awk** Awk is either a really good language or a really bad pick depending on the problem. Here it worked out nicely, short solution as well.
- **8**. **elixir** Probably a good language for many things, but not for day 8.
- **9**. **zig** Great language overall, I could definitely see it as a c alternative, its just a bit of a pain to work with allocated objects.
- **10**. **brainfuck** A bit too high level.
- **11**. **clojure** The java interop is really handy (i.e http requests), the language is nice, I just had a hard time with part 2
- **12**. **go** Not the best time with this challenge, I tink I just didn't spend enough time to understand how go arrays worked and that came back to bite me in the end.
- **13**. **ocaml** I can definitely see how rust was inspired from ocaml, an all round really cool functional language
- **14**. **vim keystrokes** Had a fun time for part 1, but since I don't think I could have really optimized anything in the "code" and I was looking at at least 2 hours of runtime, I decided to solve part 2 in rust.
- **15**. **perl** Had a hard time finding real documentation, definitely an interesting language, but I don't think I see a real reason for it now, especially with python, lua even bash nowadays.
- **16**. **javascript** I couldn't figure out part 2 for the life of me, ended up giving up.
- **17**. **fortran** Didn't expect fortran to be this powerful, you see how old the language is by the syntax, but outside of that you get almost of modern language.
- **18**. **common lisp** Not much documentation, and I wasn't really gonna read a whole book for a challenge. Being multiparadigme and having mutability is quite nice for parsing and some algorithms.
- **19**. **v** Compilation was surpisingly slow, but (from what I understand) recompiling the entire v stdlib every time probably doesn't help, relatively fast language, and easy concurency let tme bruteforce part2 in about 10 min.
- **20**. **ruby** Easy challenge, nice language with some cool features, a bit slow though.
- **21**. **scala** Challenge was pretty simple, first time working with this kind of math thing (reducing expressions), scala is an interesting language, but felt really heavy (my shell prompt was slower, running the sbt command takes >1s), it wasn't actually that slow though (metals reacted instantly, and `~run` finished executing before I could switch the see the result). The language in itself is pretty good, but I'm not too convinced by the OOP.
- **22**. **C#** Can't say I've been charmed by the language, having seen all the ones above before, going back to a verbose, rigid language with a c like syntax isn't really fun, especially since you never benifit much from OOP in those challenges. Setting up was also a bit of a pain, and I ended up going without LSP because I coudldn't be bothered. Should be more convenient on Windows though. (Also for the challenge, creating a simple paper model of the cube really helped wrapping my head around the wrapping).
- **23**. **python**
- **24**. **C++**
- **25**. **kotlin**

